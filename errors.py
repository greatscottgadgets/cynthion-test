import state
import usb1
import usb

"""
Base class for all exceptions which may be generated by the test.
"""
class CynthionTestError(Exception):
    def __init__(self, msg):
        self.msg = msg
        self.step = ".".join(str(s) for s in state.step)

# Define subclasses with associated three-letter codes.
for code, name in (
    ('EXC', 'UnexpectedError'),
    ('INT', 'TestStoppedError'),
    ('USR', 'FailButtonError'),
    ('DEP', 'DependencyError'),
    ('GF1', 'GF1Error'),
    ('BMP', 'BMPError'),
    ('TYC', 'TychoError'),
    ('PSU', 'PowerSupplyError'),
    ('CAL', 'CalibrationError'),
    ('LOW', 'ValueLowError'),
    ('HIG', 'ValueHighError'),
    ('WRG', 'ValueWrongError'),
    ('SHT', 'ShortError'),
    ('CMD', 'CommandError'),
    ('SLF', 'SelfTestError'),
    ('REG', 'RegisterError'),
    ('BTN', 'ButtonError'),
    ('CBL', 'CableError'),
    ('USB', 'USBCommsError'),
):
    globals()[name] = type(name, (CynthionTestError,), {'code': code})

# Text to identify USB device at fault on USB errors.
USBCommsError.device = "EUT"
GF1Error.device = "GreatFET"
BMPError.device = "Black Magic Probe"

# Override __init__ method in GF1Error to mark the GF1 no longer usable.
def __init__(self, msg):
    CynthionTestError.__init__(self, msg)
    state.gf = None
GF1Error.__init__ = __init__

"""
Takes an exception and if it is not a CynthionTestError, raises a
suitable CynthionTestError wrapper.
"""
def wrap_exception(exc, usb_err_type=USBCommsError):
    usb_exceptions = (usb.USBError, usb1.USBError)
    if isinstance(exc, CynthionTestError):
        return
    elif isinstance(exc, KeyboardInterrupt):
        raise TestStoppedError("Test stopped by keyboard interrupt.")
    elif isinstance(exc, usb_exceptions):
        raise usb_err_type(
            f"{usb_err_type.device} USB error: {exc.strerror}")
    else:
        raise UnexpectedError(str(exc))

"""
Context manager which converts non-CynthionTestError exceptions.
"""
class error_conversion():
    def __init__(self, usb_err_type=USBCommsError):
        self.usb_err_type = usb_err_type
    def __enter__(self):
        pass
    def __exit__(self, exc_type, exc_value, exc_tb):
        if exc_value is not None:
            wrap_exception(exc_value, self.usb_err_type)
        return False
